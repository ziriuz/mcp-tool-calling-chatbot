import random
import string
import subprocess

from langchain_core.tools import tool
from pandas import DataFrame
from typing_extensions import Tuple

from sqllite_datasource import SqlLiteDatasource


def generate_random_string(length=8):
    """Generate random string of given length"""
    characters = string.ascii_letters + string.digits
    return ''.join(random.choice(characters) for _ in range(length))


def clean_utf8_text(text):
    #  to fix: UnicodeEncodeError:
    #  'utf-8' codec can't encode character '\ude80' in position 108114: surrogates not allowed
    """Clean text by removing surrogates"""
    return text.encode("utf-8", "surrogatepass").decode("utf-8", "replace")


def parse_response(input_str: str) -> dict:
    """
    Parses input string to extract model thoughts and response text.

    Args:
        input_str (str): Input string that may contain <think>...</think> pattern
            followed by response text

    Returns:
        dict: Dictionary with two keys:
            - 'model-thoughts': Text between <think> and </think> tags, or None if tags not found
            - 'response-text': Text after </think>, or entire input if tags not found

    Examples:
        >>> parse_response("<think>Some text</think>Response")
        {'model-thoughts': 'Some text', 'response-text': 'Response'}

        >>> parse_response("Just a response")
        {'model-thoughts': None, 'response-text': 'Just a response'}
    """
    result = {
        'model-thoughts': None,
        'response-text': input_str
    }

    # Check if input contains think tags
    think_start = input_str.find('<think>')
    think_end = input_str.find('</think>')

    if think_start != -1 and think_end != -1:
        # Extract text between think tags
        thoughts = input_str[think_start + 7:think_end]
        # Extract text after closing think tag
        response = input_str[think_end + 8:]

        result['model-thoughts'] = thoughts
        result['response-text'] = response

    return result


def run_subprocess(command):
    try:
        # Start the process
        process = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            shell=True,
            encoding='utf-8'
        )
        for line in iter(process.stdout.readline, ''):
            yield line.rstrip()
            yield "\n"

        # Wait for the process to complete and get the return code
        return_code = process.wait()
        yield f"Process finished with return code {return_code}"

    except KeyboardInterrupt:
        yield "Process interrupted by user"

    except Exception as e:
        yield f"Failed to execute command\n"
        yield f"Exception: {e}"


@tool()
def command_exec_tool(command: str) -> str:
    """
    Execute linux command and return output from stdout
    Call this whenever you need to know info about files,
    for example: `how many lines in file test.txt`

    Args:
        command: linux command

    Returns:
        output from stdout generated by command
    """
    output = ""
    for line in run_subprocess(command):
        output += clean_utf8_text(line)
    return output


@tool(response_format="content_and_artifact")
def sql_exec_tool(statement: str) -> Tuple[str, DataFrame]:
    """
    Executes sql statement and return output as DataFrame.
    Call this whenever you need to know info about departments and employees from HR Database.
    HR Database is SqlLight with following schema:[
    CREATE TABLE departments (
        department_id INTEGER PRIMARY KEY,
    department_name VARCHAR
    );
    CREATE TABLE employee (
        emp_id INTEGER PRIMARY KEY,
        first_name VARCHAR,
        last_name VARCHAR,
        salary INTEGER,
        department_id INTEGER,
        FOREIGN KEY(department_id) REFERENCES departments(department_id)
    );
    ]
    SQL statement should contain column names in select list prefixed by table name or alias, `*` should not be used.

    Arguments:
        statement: SQL statement compatible with SqlLite database

    Returns:
        DataFrame with result from execution of SQL
    """
    db = SqlLiteDatasource("data/hr.db")
    df = db.retrieve_as_dataframe(statement)
    return df.to_markdown(), df


@tool()
def conversational_response(ai_response: str) -> str:
    """
    Respond in a conversational manner. Be kind and helpful.

    Args:
        ai_response: A conversational response to the user's query

    Returns:
        ai_response
    """
    return ai_response

