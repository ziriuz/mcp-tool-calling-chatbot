import pandas as pd
from langchain_core.callbacks import CallbackManagerForToolRun
from langchain_core.language_models import BaseChatModel
from langchain_core.messages import SystemMessage, HumanMessage
from langchain_core.tools import BaseTool
from langchain_core.tools.base import ArgsSchema
from langgraph.graph import START, END, StateGraph
from pydantic import Field, BaseModel
from typing_extensions import TypedDict, Optional, Any, Tuple
import prompt_templates
from models import Models
from sqllite_datasource import SqlLiteDatasource


class SQLExecutorState(TypedDict):
    query: str  # Human message to LLM
    db_schema: str  # Database schema describe all tables
    execute_mode: bool  # True if SQL should be executed automatically
    instruction: str  # System message with instruction to LLM
    sql: str  # Statement generated by LLM
    info: str  # Description of SQL statement
    success: bool  # Indicator that sql generated successfully
    result: dict  # result of SQL execution.


class SQLExecutorAgent:

    def __init__(self, datasource: SqlLiteDatasource, chat_model: BaseChatModel):
        self.__llm = chat_model
        self.__graph = self.__build_graph()
        self.__db_schema = datasource.get_schema()
        self.__db = datasource

    def __get_instruction(self, state: SQLExecutorState):
        print("__get_instruction || Returning instruction to LLM")
        return {"instruction": prompt_templates.SQL_GENERATOR_SYSTEM_INSTRUCTION.format(self.__db_schema)}

    def __generate_sql(self, state: SQLExecutorState):
        print("__generate_sql || Request LLM to generate input for 'SQL Executor' tool")

        messages = [
            SystemMessage(content=state["instruction"]),
            HumanMessage(content=state["query"])
        ]

        llm_response = self.__llm.invoke(messages)

        sql_response = llm_response.content
        print(f"SQL Response: {sql_response}")

        sql_string = sql_response \
            .replace('```sql', '') \
            .replace('```', '') \
            .strip()

        response = {
            'sql': sql_string,
            'info': f"SQL statement generated by {self.get_llm_name()}",
            'success': True if len(sql_string) > 0 else False
        }

        print(f"__generate_sql || Response generated: {response}")
        return response

    def __execute_sql(self, state: SQLExecutorState):
        print(f"__execute_sql || Tool called, executing SQL: {state}")
        dataframe = None
        if not state["success"]:
            output = "Error generating sql from user query"
        elif not state["execute_mode"]:
            output = f"SQL generated: {state['sql']}"
        else:
            output = f"Executing SQL: {state['sql']}"
            dataframe = self.__db.retrieve_as_dataframe(state['sql'])

        print(f"__execute_sql || Response generated: {output}")

        return {"result": {'message': output, 'dataframe': dataframe}}

    def __build_graph(self):

        # Compile application graph
        graph_builder = StateGraph(SQLExecutorState).add_sequence(
            [self.__get_instruction, self.__generate_sql, self.__execute_sql]
        )
        graph_builder.add_edge(START, "__get_instruction")
        graph_builder.add_edge("__execute_sql", END)
        graph = graph_builder.compile()

        return graph

    def invoke(self, query: str, execute_mode: bool = False):
        return self.__graph.invoke({"query": query, "execute_mode": execute_mode})

    def get_graph_image(self):
        return self.__graph.get_graph().draw_mermaid_png()

    def get_llm_name(self):
        return self.__llm.model


class DatabaseRetrievalInput(BaseModel):
    query: str = Field(description="Data retrieval Query in natural language")


# Note: It's important that every field has type hints. BaseTool is a
# Pydantic class and not having type hints can lead to unexpected behavior.
class DatabaseRetrievalTool(BaseTool):
    name: str = "database_retrieval"
    description: str = """
        Retrieves information from a database by converting natural language query into SQL statement and executing it.
        Call this whenever you need to retrieve information about: {db_description}
    """
    args_schema: Optional[ArgsSchema] = DatabaseRetrievalInput
    return_direct: bool = True
    response_format: str = "content_and_artifact"
    sql_executor: SQLExecutorAgent = None
    db_description: str = "HR DB"

    def __init__(self, datasource: Any, db_description: str, chat_model: BaseChatModel, **kwargs: Any):
        super().__init__(**kwargs)
        self.db_description = db_description
        self.description = self.description.format(db_description=db_description)
        self.sql_executor = SQLExecutorAgent(datasource, chat_model=chat_model)

    def _run(
            self, query: str, run_manager: Optional[CallbackManagerForToolRun] = None
    ) -> Tuple[str, pd.DataFrame]:
        """Use the tool."""
        response = self.sql_executor.invoke(query, True)
        df: pd.DataFrame = response["result"]["dataframe"]
        return df.to_markdown(), df

    # async def _arun(
    #         self,
    #         a: int,
    #         b: int,
    #         run_manager: Optional[AsyncCallbackManagerForToolRun] = None,
    # ) -> str:
    #     """Use the tool asynchronously."""
    #     # If the calculation is cheap, you can just delegate to the sync implementation
    #     # as shown below.
    #     # If the sync calculation is expensive, you should delete the entire _arun method.
    #     # LangChain will automatically provide a better implementation that will
    #     # kick off the task in a thread to make sure it doesn't block other async code.
    #     return self._run(a, b, run_manager=run_manager.get_sync())


def print_state(state: SQLExecutorState):
    print("=============================================")
    print(f"query:\n{state.get('query', 'None')}")
    print("---------------------------------------------")
    print(f"db_schema:\n{state.get('db_schema', 'None')}")
    print("---------------------------------------------")
    print(f"execute_mode:\n{state.get('execute_mode', 'None')}")
    print("---------------------------------------------")
    print(f"instruction:\n{state.get('instruction', 'None')}")
    print("---------------------------------------------")
    print(f"sql:\n{state.get('sql', 'None')}")
    print("---------------------------------------------")
    print(f"success:\n{state.get('success', 'None')}")
    print("---------------------------------------------")
    print(f"result:\n{state.get('result', 'None')}")
    print("=============================================")


if __name__ == '__main__':

    chat = Models.create_chat(Models.QWEN25_CODER_7B, temperature=0.5)

    db_retrieval = DatabaseRetrievalTool(SqlLiteDatasource("data/hr.db"),
                                         db_description="departments and employees, including salaries",
                                         chat_model=chat)
    response = db_retrieval.invoke("show all departments")

    print(response)
