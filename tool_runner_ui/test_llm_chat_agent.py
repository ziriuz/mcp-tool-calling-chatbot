from langchain_core.tools import tool
from pandas import DataFrame
from typing_extensions import Tuple
import tools
from llm_chat_agent import LLMChatState, LLMChatAgent, ToolConfig, CallAgentTool
from logger import Logger
from models import Models
from sqllite_datasource import SqlLiteDatasource

BASE_URL = "http://localhost:11434"

# Default System instruction message used in LLMChatAgent constructor if system message not explicitly provided
# put it here just for reference
QA_ASSISTANT_INSTRUCTION = """
You are an assistant for question-answering tasks. 
- Always be accurate. If you don't know the answer, say that you don't know.
- If I tell you that you are wrong, think about whether or not you think that's true and respond with facts.
- Avoid apologizing or making conciliatory statements.
- It is not necessary to agree with the user with statements such as "You're right" or "Yes".
- Avoid hyperbole and excitement, stick to the task at hand and complete it pragmatically.
"""

# this one is added as system message internally in LLMChatAgent constructor if tools are provided
# put it here just for reference
TOOL_CALLING_SYSTEM_MESSAGE = """
You can use available tools to retrieve additional information or respond directly with your own answer.
When User approval is required to run any tool Then ask user for confirmation.
Given tool is called, 
When tool returns error in response, 
Then fix input and try to call that tool one more time (You have {max_attempts} attempts to fix error).
Avoid mentioning errors and fixes you have done in final response, just provide answer to question.
When unable to fix errors after all attempts say `I cannot answer this question`.    
"""


# (!) Note that Doc string contains information about data stored in DB and DB schema.
# DB schema described by DDL in this case, but it is not necessary to use DDL, any format can be used.
@tool(response_format="content_and_artifact")
def sql_exec_tool(statement: str) -> Tuple[str, DataFrame]:
    """
    Executes sql statement and return output as DataFrame.
    Call this whenever you need to know info about departments and employees from HR Database.
    HR Database is SqlLight with following schema:[
    CREATE TABLE departments (
        department_id INTEGER PRIMARY KEY,
    department_name VARCHAR
    );
    CREATE TABLE employee (
        emp_id INTEGER PRIMARY KEY,
        first_name VARCHAR,
        last_name VARCHAR,
        salary INTEGER,
        department_id INTEGER,
        FOREIGN KEY(department_id) REFERENCES departments(department_id)
    );
    ]
    SQL statement should contain column names in select list prefixed by table name or alias, `*` should not be used.

    Arguments:
        statement: SQL statement compatible with SqlLite database

    Returns:
        DataFrame with result from execution of SQL
    """
    db = SqlLiteDatasource("data/hr.db")
    dataframe = db.retrieve_as_dataframe(statement)
    return dataframe.to_markdown(), dataframe


def create_agent():

    # 1.
    # Creating 2 chat models: one for generating code/SQL, another for reasoning of user queries
    coding_model = Models.create_chat(Models.LLAMA_3B, base_url=BASE_URL, temperature=0.3)
    chatting_model = Models.create_chat(Models.LLAMA_3B, base_url=BASE_URL, temperature=0.05)

    # 2.
    # Creating `DB Retrieval Agent` with only one tool in arsenal: sql_exec_tool
    # this agent performs only one specific task:
    # convert user query in natural language to SQL, execute generated SQL and respond with data retrieved from DB
    db_agent = LLMChatAgent(
        "DB Retrieval Agent", Logger.GREEN, coding_model,
        system_message="You are Database retrieval agent. " +
                       "Convert user query to SQL and call sql_exec_tool to execute SQL and get data. " +
                       "When generating final response, just return correct response generated by tool.",
        # (!) Under the hood ollama API backend will add Definition of sql_exec_tool to System instruction massage
        toolkit={"sql_exec_tool": ToolConfig(tools.sql_exec_tool, False, True)}
    )

    # 3.
    # Creating a tool to interact with `DB Retrieval Agent`
    # (!) Note that description contains information about what data is stored in DB, as db_agent very specific
    db_retrieval_tool = CallAgentTool(
        name="hr_assistant",
        # description="""
        # Retrieves information from a database by converting natural language query into SQL statement and executing it.
        # Call this whenever you need to retrieve information about: departments and employees, including salaries
        # """,
        description="""
        Provides HR related information.
        Call this whenever you need information about: departments and employees, including salaries
        """,
        agent=db_agent
    )

    # 4.
    # Tools for `User Assistant Agent`.
    # (!) Note that multiple tools can be used by model. During reasoning model might select one or several tools.
    # (!) Note that one of the tools is `hr_assistant` which is sending request to another agent
    toolkit = {
        "conversational_response": ToolConfig(tools.conversational_response, True, True),
        "hr_assistant": ToolConfig(db_retrieval_tool, False, True),
        "command_exec_tool": ToolConfig(tools.command_exec_tool, False, False)
    }

    # 5.
    # Creating `User Assistant Agent` to handle user queries
    user_assistant_agent = LLMChatAgent(
        "User Assistant Agent", Logger.BLUE, chatting_model,
        system_message=QA_ASSISTANT_INSTRUCTION,
        # (!) Under the hood ollama API backend will add Definitions of all tools to System instruction massage
        toolkit=toolkit
    )
    return user_assistant_agent


def print_state(state: LLMChatState):
    print("=============================================")
    print(f"query:\n{state.get('query', 'None')}")
    print("---------------------------------------------")
    print(f"execute_mode:\n{state.get('execute_mode', 'None')}")
    print("---------------------------------------------")
    print(f"instruction:\n{state.get('instruction', 'None')}")
    print("---------------------------------------------")
    print(f"command:\n{state.get('command', 'None')}")
    print("---------------------------------------------")
    print(f"success:\n{state.get('success', 'None')}")
    print("---------------------------------------------")
    print(f"output:\n{state.get('output', 'None')}")
    print("---------------------------------------------")
    print(f"artifacts:\n{state.get('artifacts', 'None')}")
    print("=============================================")


if __name__ == '__main__':

    assistant = create_agent()

    answer = assistant.invoke("How many people works in each department?", False)
    print(answer["output"])

    answer = assistant.invoke("show all files with details in `./files` directory", True)
    print(answer["output"])

